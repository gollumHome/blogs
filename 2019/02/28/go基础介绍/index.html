<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="参考文档121.https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.5.md2.http://tour.studygolang.com/welcome/1  Go 程序的基本结构和要素示例hello_world.go1234567package mainimport &amp;quot;fmt&amp;quot;func main">
<meta property="og:type" content="article">
<meta property="og:title" content="go基础介绍.md">
<meta property="og:url" content="http://yoursite.com/2019/02/28/go基础介绍/index.html">
<meta property="og:site_name" content="openstack">
<meta property="og:description" content="参考文档121.https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.5.md2.http://tour.studygolang.com/welcome/1  Go 程序的基本结构和要素示例hello_world.go1234567package mainimport &amp;quot;fmt&amp;quot;func main">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-03-03T13:24:10.769Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="go基础介绍.md">
<meta name="twitter:description" content="参考文档121.https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.5.md2.http://tour.studygolang.com/welcome/1  Go 程序的基本结构和要素示例hello_world.go1234567package mainimport &amp;quot;fmt&amp;quot;func main">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/02/28/go基础介绍/">





  <title>go基础介绍.md | openstack</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">openstack</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/go基础介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuai Guo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="openstack">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">go基础介绍.md</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-28T22:04:44+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>参考文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.5.md</span><br><span class="line">2.http://tour.studygolang.com/welcome/1</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Go 程序的基本结构和要素<br>示例hello_world.go<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;hello, world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>1.1 包的概念、导入与可见性<br>1&gt;每个程序都由包（通常简称为pkg）的概念组成，可以使用自身的包或者从其它包中导入内容<br>2&gt;每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成<br>3&gt;必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main,所有的包名都应该使用小写字母  </p>
<p>引入多个包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;os&quot;</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;; import &quot;os&quot;</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;os&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>可见性规则<br>1&gt;当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）<br>2&gt;标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）</p>
<p>1.2. 函数<br>符合规范的函数一般写成如下的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func functionName(parameter_list) (return_value_list) &#123;</span><br><span class="line">   …</span><br><span class="line">&#125;</span><br><span class="line">注：1.函数需要被外部包调用的时候使用大写字母开头，遵循骆驼命名法。</span><br><span class="line">    2.左大括号 &#123; 必须与方法的声明放在同一行，这是编译器的强制规定，否则你在使用 gofmt 时就会出现错误提示</span><br><span class="line">    `build-error: syntax error: unexpected semicolon or newline before &#123;`</span><br></pre></td></tr></table></figure></p>
<p>1.3 函数返回值<br>函数可以拥有多返回值，返回类型之间需要使用逗号分割，并使用小括号 () 将它们括起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func FunctionName (a typea, b typeb) (t1 type1, t2 type2)</span><br></pre></td></tr></table></figure></p>
<p>1.4 注释<br>以 // 开头的单行注释<br>多行注释也叫块注释，均已以 /<em> 开头，并以 </em>/ 结尾<br>1.5 基本类型<br>int、float、bool、string；结构化的（复合的），如：struct、array、slice、map、channel；只描述类型行为，如：interface<br>结构化的类型没有真正的值，它使用 nil 作为默认值<br>1.6 类型转换<br> Go 语言不存在隐式类型转换，必须显式说明<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := 5.0</span><br><span class="line">b := int(a)</span><br></pre></td></tr></table></figure></p>
<p>1.5 变量<br>使用 var 关键字：var identifier type<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a, b *int</span><br><span class="line">var a int</span><br><span class="line">var b bool</span><br><span class="line">var str string</span><br><span class="line">或</span><br><span class="line">var (</span><br><span class="line">	a int</span><br><span class="line">	b bool</span><br><span class="line">	str string</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>赋值<br>a = 11<br>var c int = 12<br>:= 赋值操作符初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以在变量的初始化时省略变量的类型而由系统自动推断  </span><br><span class="line">a := 50</span><br></pre></td></tr></table></figure></p>
<p>1.6 init 函数<br>1&gt;一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高<br>2&gt;每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行  </p>
<p>可能的用途：  变量初始化 init.go<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package trans</span><br><span class="line"></span><br><span class="line">import &quot;math&quot;</span><br><span class="line"></span><br><span class="line">var Pi float64</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">   Pi = 4 * math.Atan(1) // init() function computes Pi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.7 指针<br>Go 语言为程序员提供了控制数据结构的指针的能力,不允许指针运算-&gt;移动指针位置<br>pointer.go<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var i1 = 5</span><br><span class="line">fmt.Printf(&quot;An integer: %d, it&apos;s location in memory: %p\n&quot;, i1, &amp;i1)</span><br><span class="line">-----------------------</span><br><span class="line">可能输出  </span><br><span class="line">An integer: 5, its location in memory: 0x6b0820</span><br></pre></td></tr></table></figure></p>
<p>定义一个指针变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var intP *int</span><br><span class="line"></span><br><span class="line">*intP，将得到这个指针指向地址上所存储的值</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>函数<br> 函数是 Go 里面的基本代码块,Go 里面有三种类型的函数：<br>. 普通的带有名字的函数<br>. 匿名函数或者lambda函数<br>. 方法Methods<br>==注：除了main()、init()函数外，其它所有类型的函数都可以有参数与返回值。函数参数==、==返回值以及它们的类型被统称为函数签==名  </li>
</ol>
<p>2.1 按值传递、按引用传递<br>    1&gt;默认使用按值传递来传递参数，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量<br>    2&gt; 如果函数直接修改参数的值，而不是对参数的副本进行操作，需要按引用传递，即变量名前面添加&amp;符号<br>注：函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）</p>
<p>2.2 传递变长参数<br>函数的最后一个参数是采用 …type 的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func myFunc(a, b, arg ...int) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.3  defer 函数<br>defer 语句会将函数推迟到外层函数返回之后执行<br>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用<br>==使用场景：一般用于释放某些已分配的资源==<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	defer fmt.Println(&quot;world&quot;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure></p>
<p>2.4 回调<br>函数可以作为其它函数的参数进行传递<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	callback(1, Add)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Add(a, b int) &#123;</span><br><span class="line">	fmt.Printf(&quot;The sum of %d and %d is: %d\n&quot;, a, b, a+b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func callback(y int, f func(int, int)) &#123;</span><br><span class="line">	f(y, 2) // this becomes Add(1, 2)</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------</span><br><span class="line">The sum of 1 and 2 is: 3</span><br></pre></td></tr></table></figure></p>
<p>2.5 闭包<br>匿名函数被称之为闭包</p>
<ol start="3">
<li><p>数组、切片、Map<br>3.1. 数组的长度是其类型的一部分，因此数组不能改变大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125;</span><br></pre></td></tr></table></figure>
<p>3.2. 切片：<br>切片（slice）是对数组一个连续片段的引用，切片则为数组元素提供动态大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔</span><br><span class="line"></span><br><span class="line">primes := [6]int&#123;2, 3, 5, 7, 11, 13&#125; --&gt;数组</span><br><span class="line">var s []int = primes[1:4]  -&gt;切片</span><br></pre></td></tr></table></figure>
<p>3.3 maek 创建切片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := make([]int, 5)</span><br></pre></td></tr></table></figure>
<p>3.3 切片文法<br>切片文法类似于没有长度的数组文法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q := []int&#123;2, 3, 5, 7, 11, 13&#125;</span><br></pre></td></tr></table></figure>
<p>3.4 for - range  </p>
<p>for 循环的 range 形式可遍历切片或映射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> for ix, value := range slice1 &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var pow = []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	for i, v := range pow &#123;</span><br><span class="line">		fmt.Printf(&quot;2**%d = %d\n&quot;, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------</span><br><span class="line">2**0 = 1</span><br><span class="line">2**1 = 2</span><br><span class="line">2**2 = 4</span><br></pre></td></tr></table></figure></p>
<p>3.5 MAP使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var map1 map[keytype]valuetype</span><br><span class="line">var map1 map[string]int</span><br></pre></td></tr></table></figure></p>
<p>测试键值对是否存在及删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val1, isPresent = map1[key1]</span><br><span class="line">isPresent 返回一个 bool 值：如果 key1 存在于 map1，val1 就是 key1 对应的 value 值，并且 isPresent为true；如果 key1 不存在，val1 就是一个空值，并且 isPresent 会返回 false</span><br><span class="line"></span><br><span class="line">如果你只是想判断某个 key 是否存在而不关心它对应的值</span><br><span class="line">_, ok := map1[key1] // 如果key1存在则ok == true，否则ok为false</span><br><span class="line">与if 混合使用</span><br><span class="line">if _, ok := map1[key1]; ok &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>for-range 的map配套用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, value := range map1 &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果只关心值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _, value := range map1 &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果只想获取 key，你可以这么使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for key := range map1 &#123;</span><br><span class="line">	fmt.Printf(&quot;key is: %d\n&quot;, key)</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">4. 控制结构</span><br><span class="line"></span><br><span class="line">4.1 if-else结构</span><br><span class="line"></span><br><span class="line">Go 完全省略了 if、switch 和 for 结构中条件语句两侧的括号，相比 Java、C++ 和 C# 中减少了很多视觉混乱的因素，同时也使你的代码更加简洁。</span><br></pre></td></tr></table></figure></p>
<p>if condition {<br>    // do something<br>} else {<br>    // do something<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关键字 if 和 else 之后的左大括号 &#123; 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 &#125; 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。</span><br><span class="line">非法的 Go 代码:</span><br></pre></td></tr></table></figure></p>
<p>if x{<br>}<br>else {    // 无效的<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当 if 结构内有 break、continue、goto 或者 return 语句时，Go 代码的常见写法是省略 else 部分。无论满足哪个条件都会返回 x 或者 y 时，一般使用以下写法：</span><br></pre></td></tr></table></figure></p>
<p>if condition {<br>    return x<br>}<br>return y<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.2 switch结构</span><br><span class="line"></span><br><span class="line">相比较 C 和 Java 等其它语言而言，Go 语言中的 switch 结构使用上更加灵活。它接受任意形式的表达式：</span><br></pre></td></tr></table></figure></p>
<p>switch var1 {<br>    case val1:<br>        …<br>    case val2:<br>        …<br>    default:<br>        …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">4.3 for结构</span><br><span class="line"></span><br><span class="line">4.3.1 基于计数器的迭代</span><br><span class="line"></span><br><span class="line">基本形式为</span><br><span class="line">`for 初始化语句; 条件语句; 修饰语句 &#123;&#125;`</span><br><span class="line"></span><br><span class="line">4.3.2 基于条件判断</span><br><span class="line">基本形式为</span><br><span class="line">`for 条件语句 &#123;&#125;`</span><br><span class="line"></span><br><span class="line">4.3.3 无限循环</span><br><span class="line"></span><br><span class="line">条件语句被省略</span><br><span class="line"></span><br><span class="line">4.3.4 这里介绍 Go 特有的一种的for-range迭代结构</span><br></pre></td></tr></table></figure></p>
<p>for ix, val := range coll { }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">要注意的是，val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值</span><br><span class="line"></span><br><span class="line">4.4 break和continue  </span><br><span class="line"></span><br><span class="line">break被用于任何形式的for循环以及switch或select语句，continue只能被用于for循环  </span><br><span class="line"></span><br><span class="line">5. 结构struct与方法method  </span><br><span class="line"></span><br><span class="line">5.1 结构体定义的一般方式如下：</span><br></pre></td></tr></table></figure></p>
<p>type identifier struct {<br>    field1 type1<br>    field2 type2<br>    …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5.2 使用 new 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针：var t *T = new(T)</span><br><span class="line">访问结构体变量或赋值</span><br></pre></td></tr></table></figure></p>
<p>structname.fieldname<br>structname.fieldname = value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5.3 匿名字段和内嵌结构体  </span><br><span class="line">结构体可以包含一个或多个 匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。匿名字段本身可以是一个结构体类型，即 结构体可以包含内嵌结构体</span><br></pre></td></tr></table></figure></p>
<p>package main</p>
<p>import “fmt”</p>
<p>type A struct {<br>    ax, ay int<br>}</p>
<p>type B struct {<br>    A<br>    bx, by float32<br>}</p>
<p>func main() {<br>    b := B{A{1, 2}, 3.0, 4.0}<br>    fmt.Println(b.ax, b.ay, b.bx, b.by)<br>    fmt.Println(b.A)</p>
<h2 id><a href="#" class="headerlink" title="}"></a>}</h2><p>1 2 3 4<br>{1 2}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5.4 方法  </span><br><span class="line">结构体就像是类的一种简化形式，类似于OOP中有方法的实现，Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数  </span><br><span class="line">定义方法的一般格式如下：</span><br></pre></td></tr></table></figure></p>
<p>func (recv receiver_type) methodName(parameter_list) (return_value_list) { … }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：method .go</span><br></pre></td></tr></table></figure></p>
<p>package main</p>
<p>import “fmt”</p>
<p>type TwoInts struct {<br>    a int<br>    b int<br>}</p>
<p>func main() {<br>    two1 := new(TwoInts)<br>    two1.a = 12<br>    two1.b = 10</p>
<pre><code>fmt.Printf(&quot;The sum is: %d\n&quot;, two1.AddThem())
fmt.Printf(&quot;Add them to the param: %d\n&quot;, two1.AddToParam(20))

two2 := TwoInts{3, 4}
fmt.Printf(&quot;The sum is: %d\n&quot;, two2.AddThem())
</code></pre><p>}</p>
<p>func (tn *TwoInts) AddThem() int {<br>    return tn.a + tn.b<br>}</p>
<p>func (tn *TwoInts) AddToParam(param int) int {<br>    return tn.a + tn.b + param<br>}</p>
<hr>
<p>The sum is: 22<br>Add them to the param: 42<br>The sum is: 7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内嵌类型的方法和继承  </span><br><span class="line">当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型继承了这些方法  </span><br><span class="line">示例：method3.go</span><br></pre></td></tr></table></figure></p>
<p>package main</p>
<p>import (<br>    “fmt”<br>    “math”<br>)</p>
<p>type Point struct {<br>    x, y float64<br>}</p>
<p>func (p <em>Point) Abs() float64 {<br>    return math.Sqrt(p.x</em>p.x + p.y*p.y)<br>}</p>
<p>type NamedPoint struct {<br>    Point<br>    name string<br>}</p>
<p>func main() {<br>    n := &amp;NamedPoint{Point{3, 4}, “Pythagoras”}<br>    fmt.Println(n.Abs()) // 打印5<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6. 接口（interface）与反射（reflection）  </span><br><span class="line">接口提供了一种方式来 说明 对象的行为，接口定义了一组方法（方法集），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也不能包含变量</span><br><span class="line">5.1 一般定义为</span><br></pre></td></tr></table></figure></p>
<p>type Namer interface {<br>    Method1(param_list) return_type<br>    Method2(param_list) return_type<br>    …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 interfaces.go:</span><br></pre></td></tr></table></figure></p>
<p>package main</p>
<p>import “fmt”</p>
<p>type Shaper interface {<br>    Area() float32<br>}</p>
<p>type Square struct {<br>    side float32<br>}</p>
<p>func (sq <em>Square) Area() float32 {<br>    return sq.side </em> sq.side<br>}</p>
<p>func main() {<br>    sq1 := new(Square)<br>    sq1.side = 5</p>
<pre><code>var areaIntf Shaper
areaIntf = sq1
// shorter,without separate declaration:
// areaIntf := Shaper(sq1)
// or even:
// areaIntf := sq1
fmt.Printf(&quot;The square has area: %f\n&quot;, areaIntf.Area())
</code></pre><p>}<br>注：接口变量包含一个指向 Square 变量的引用，通过它可以调用 Square 上的方法 Area()，接口变量里包含了接收者实例的值和指向对应方法表的指针</p>
<h2 id="当前示例即是Go-版本的多态，同一种类型在不同的实例上似乎表现出不同的行为"><a href="#当前示例即是Go-版本的多态，同一种类型在不同的实例上似乎表现出不同的行为" class="headerlink" title="当前示例即是Go 版本的多态，同一种类型在不同的实例上似乎表现出不同的行为"></a>当前示例即是Go 版本的多态，同一种类型在不同的实例上似乎表现出不同的行为</h2><p>The square has area: 25.000000</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6.2 接口嵌套  </span><br><span class="line">一个接口可以包含一个或多个其他的接口，相当于直接将这些内嵌接口的方法列举在外层接口中一样</span><br></pre></td></tr></table></figure>
<p>type ReadWrite interface {<br>    Read(b Buffer) bool<br>    Write(b Buffer) bool<br>}</p>
<p>type Lock interface {<br>    Lock()<br>    Unlock()<br>}</p>
<p>type File interface {<br>    ReadWrite<br>    Lock<br>    Close()<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6.3 反射  </span><br><span class="line">反射是用程序检查其所拥有的结构，尤其是类型的一种能力，反射可以在运行时检查类型和变量，例如它的大小、方法和 动态 的调用这些方法  </span><br><span class="line">reflect.TypeOf 和 reflect.ValueOf，返回被检查对象的类型和值</span><br><span class="line">示例 reflect1.go</span><br></pre></td></tr></table></figure></p>
<p>// blog: Laws of Reflection<br>package main</p>
<p>import (<br>    “fmt”<br>    “reflect”<br>)</p>
<p>func main() {<br>    var x float64 = 3.4<br>    fmt.Println(“type:”, reflect.TypeOf(x))<br>    v := reflect.ValueOf(x)<br>    fmt.Println(“value:”, v)<br>    fmt.Println(“type:”, v.Type())<br>    fmt.Println(“kind:”, v.Kind())<br>    fmt.Println(“value:”, v.Float())<br>    fmt.Println(v.Interface())<br>    fmt.Printf(“value is %5.2e\n”, v.Interface())<br>    y := v.Interface().(float64)<br>    fmt.Println(y)</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="}"></a>}</h2><p>type: float64<br>value: 3.4<br>type: float64<br>kind: float64<br>value: 3.4<br>3.4<br>value is 3.40e+00<br>3.4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">7. 错误处理  </span><br><span class="line">7.1. 抛出错误</span><br><span class="line">1&gt;Go 运行时会触发运行时 panic，伴随着程序的崩溃抛出一个 runtime.Error 接口类型的值。这个错误值有个 RuntimeError() 方法用于区别普通错误</span><br><span class="line">2&gt;panic 接收一个做任意类型的参数，通常是字符串，在程序死亡时被打印出来</span><br><span class="line">示例 panic.go</span><br></pre></td></tr></table></figure></p>
<p>package main</p>
<p>import “fmt”</p>
<p>func main() {<br>    fmt.Println(“Starting the program”)<br>    panic(“A severe error occurred: stopping the program!”)<br>    fmt.Println(“Ending the program”)</p>
<h2 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h2><p>Starting the program<br>panic: A severe error occurred: stopping the program!<br>panic PC=0x4f3038<br>runtime.panic+0x99 /go/src/pkg/runtime/proc.c:1032<br>       runtime.panic(0x442938, 0x4f08e8)<br>main.main+0xa5 E:/Go/GoBoek/code examples/chapter 13/panic.go:8<br>       main.main()<br>runtime.mainstart+0xf 386/asm.s:84<br>       runtime.mainstart()<br>runtime.goexit /go/src/pkg/runtime/proc.c:148<br>       runtime.goexit()<br>—- Error run E:/Go/GoBoek/code examples/chapter 13/panic.exe with code Crashed<br>—- Program exited with code -1073741783<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">7.2 从 panic 中恢复（Recover）  </span><br><span class="line">（recover）内建函数被用于从 panic 或 错误场景中恢复：让程序可以从 panicking 重新获得控制权，停止终止过程进而恢复正常执行  </span><br><span class="line">使用方式：  </span><br><span class="line">recover 只能在 defer 修饰的函数中使用：用于取得 panic 调用中传递过来的错误值，如果是正常执行，调用 recover 会返回 nil  </span><br><span class="line">示例： recover.go</span><br></pre></td></tr></table></figure></p>
<p>func protect(g func()) {<br>    defer func() {<br>        log.Println(“done”)<br>        // Println executes normally even if there is a panic<br>        if err := recover(); err != nil {<br>        log.Printf(“run time panic: %v”, err)<br>        }<br>    }()<br>    log.Println(“start”)<br>    g() //   possible runtime-error<br>}<br>注：类似于java 等catch操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8. 协程（goroutine）与通道（channel）  </span><br><span class="line">    goroutine这个概念类似于轻量级线程，运行时管理的轻量级线程</span><br></pre></td></tr></table></figure></p>
<p>go f(x, y, z)  启动一个新的 Go 程并执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8.1 changel</span><br></pre></td></tr></table></figure></p>
<p>ch &lt;- v    // 将 v 发送至信道 ch。<br>v := &lt;-ch  // 从 ch 接收值并赋予 v。</p>
<p>必须先创建changel<br>ch := make(chan int)<br>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8.2 带缓冲区changel</span><br></pre></td></tr></table></figure></p>
<p>ch := make(chan int, 100)<br>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8.3 range 和 close  </span><br><span class="line">发送者可通过 close 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</span><br></pre></td></tr></table></figure></p>
<p>v, ok := &lt;-ch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">之后 ok 会被设置为 false  </span><br><span class="line">循环 for i := range c  会不断从信道接收值，直到它被关闭</span><br></pre></td></tr></table></figure></p>
<p><em>注意：</em> 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p>
<p><em>还要注意：</em> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有值需要发送的时候才有必要关闭，例如终止一个 range 循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8.4 sync.Mutex  </span><br><span class="line">Go 标准库中提供了 sync.Mutex 互斥锁类型及其两个方法：Lock 、Unlock  </span><br><span class="line">也可以用 defer 语句来保证互斥锁一定会被解锁</span><br></pre></td></tr></table></figure></p>
<p>package main</p>
<p>import (<br>    “fmt”<br>    “sync”<br>    “time”<br>)</p>
<p>// SafeCounter 的并发使用是安全的。<br>type SafeCounter struct {<br>    v   map[string]int<br>    mux sync.Mutex<br>}</p>
<p>// Inc 增加给定 key 的计数器的值。<br>func (c *SafeCounter) Inc(key string) {<br>    c.mux.Lock()<br>    // Lock 之后同一时刻只有一个 goroutine 能访问 c.v<br>    c.v[key]++<br>    c.mux.Unlock()<br>}</p>
<p>// Value 返回给定 key 的计数器的当前值。<br>func (c *SafeCounter) Value(key string) int {<br>    c.mux.Lock()<br>    // Lock 之后同一时刻只有一个 goroutine 能访问 c.v<br>    defer c.mux.Unlock()<br>    return c.v[key]<br>}</p>
<p>func main() {<br>    c := SafeCounter{v: make(map[string]int)}<br>    for i := 0; i &lt; 1000; i++ {<br>        go c.Inc(“somekey”)<br>    }</p>
<pre><code>time.Sleep(time.Second)
fmt.Println(c.Value(&quot;somekey&quot;))
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">9. 与oop分析对比  </span><br><span class="line">封装，继承，和多态   </span><br><span class="line">封装：可以把struct看成一个类，可以看成对struct的封装</span><br></pre></td></tr></table></figure>
<p>type struct1 struct {<br>    i1  int<br>    f1  float32<br>    str string<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">继承:</span><br><span class="line">结构体的嵌套模拟继承</span><br></pre></td></tr></table></figure></p>
<p>type A struct{ //父类<br>    name string<br>    age int<br>}<br>type B struct{//子类<br>    a A // 模拟聚合关系    …..}</p>
<p>type C struct{//子类<br>    A // 模拟继承<br>}</p>
<p>b := B{}<br>b.a.name<br>c := C{}<br>b.name</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多态：  </span><br><span class="line">接口的所有方法的任何类型都表示隐式实现该接口。类型接口的变量可以保存实现该接口的任何值</span><br></pre></td></tr></table></figure>
<pre><code>package main

import (
    &quot;fmt&quot;
)

type Person interface {
    SayHello()
}

type Girl struct {
    Sex string
}

type Boy struct {
    Sex string
}

func (this *Girl) SayHello() {
    fmt.Println(&quot;Hi, I am a &quot; + this.Sex)
}

func (this *Boy) SayHello() {
    fmt.Println(&quot;Hi, I am a &quot; + this.Sex)
}

func main() {
    g := &amp;Girl{&quot;girl&quot;}
    b := &amp;Boy{&quot;boy&quot;}

    p := map[int]Person{}
    p[0] = g
    p[1] = b

    for _, v := range p {
        v.SayHello()
    } 
}
</code></pre><hr>
<pre><code>Hi, I am a boy
Hi, I am a gir
</code></pre><p><code>`</code></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/25/session-cookie-token-md/" rel="next" title="session_cookie_token.md">
                <i class="fa fa-chevron-left"></i> session_cookie_token.md
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/03/Go环境安装与调试/" rel="prev" title="Go环境安装与调试">
                Go环境安装与调试 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Shuai Guo">
            
              <p class="site-author-name" itemprop="name">Shuai Guo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/gollumHome" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="1025951714@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-qq"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/cleaner_xiaoqiang" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-csdn"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/170183273/" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-豆瓣"></i>豆瓣</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#"><span class="nav-number">1.</span> <span class="nav-text">}</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#当前示例即是Go-版本的多态，同一种类型在不同的实例上似乎表现出不同的行为"><span class="nav-number">2.</span> <span class="nav-text">当前示例即是Go 版本的多态，同一种类型在不同的实例上似乎表现出不同的行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#-1"><span class="nav-number">3.</span> <span class="nav-text">}</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#-2"><span class="nav-number">4.</span> <span class="nav-text">}</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shuai Guo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
